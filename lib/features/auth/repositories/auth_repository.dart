// Dart imports:
import 'dart:io';
import 'dart:math' as math;

// Package imports:
import 'package:supabase_flutter/supabase_flutter.dart' as supabase;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:sign_in_with_apple/sign_in_with_apple.dart';

// Project imports:
import 'package:ray_club_app/core/errors/app_exception.dart';
import 'package:ray_club_app/core/config/auth_config.dart';

/// Interface for authentication-related operations
abstract class IAuthRepository {
  /// Gets the currently authenticated user
  /// Returns null if no user is authenticated
  Future<supabase.User?> getCurrentUser();

  /// Gets the currently authenticated user's ID
  /// Returns empty string if no user is authenticated
  Future<String> getCurrentUserId();

  /// Checks if an email is already registered
  /// Returns true if the email exists in the database
  Future<bool> isEmailRegistered(String email);

  /// Signs up a new user with email and password
  /// Throws [ValidationException] if email or password is invalid
  /// Throws [AuthException] if signup fails
  Future<supabase.User> signUp(String email, String password, String name);

  /// Signs in a user with email and password
  /// Throws [ValidationException] if email or password is invalid
  /// Throws [AuthException] if credentials are incorrect
  Future<supabase.User> signIn(String email, String password);

  /// Signs out the current user
  /// Throws [AuthException] if signout fails
  Future<void> signOut();

  /// Resets the password for the given email
  /// Throws [ValidationException] if email is invalid
  /// Throws [AuthException] if reset fails
  Future<void> resetPassword(String email);

  /// Updates the current user's profile
  /// Throws [AuthException] if user is not authenticated
  /// Throws [ValidationException] if data is invalid
  Future<void> updateProfile({
    String? name, 
    String? photoUrl,
    bool? onboardingSeen,
  });

  /// Sign in with Google OAuth
  /// Throws [AuthException] if sign in fails
  Future<supabase.Session?> signInWithGoogle();

  /// Sign in with Apple OAuth
  /// Throws [AuthException] if sign in fails
  Future<supabase.Session?> signInWithApple();

  /// Obt√©m a sess√£o atual se existir
  supabase.Session? getCurrentSession();
  
  /// Obt√©m o perfil do usu√°rio atual
  /// Throws [AuthException] se o usu√°rio n√£o estiver autenticado
  Future<supabase.User?> getUserProfile();

  /// Renova a sess√£o do usu√°rio atual
  /// Throws [AuthException] se houver erro na renova√ß√£o
  Future<void> refreshSession();
  
  /// Reenvia o email de verifica√ß√£o para o endere√ßo de email fornecido
  /// Throws [ValidationException] se o email for inv√°lido
  /// Throws [AuthException] se o envio falhar
  Future<void> resendVerificationEmail(String email, String redirectUrl);
}

/// Implementation of [IAuthRepository] using Supabase
class AuthRepository implements IAuthRepository {
  final supabase.SupabaseClient _supabaseClient;
  final GoogleSignIn _googleSignIn;

  AuthRepository(this._supabaseClient) 
    : _googleSignIn = GoogleSignIn() {
    // IMPORTANTE: GoogleSignIn() SEM par√¢metros usa automaticamente
    // a configura√ß√£o do Info.plist, evitando conflitos e crashes
    
    print('');
    print('üèóÔ∏è ========== INICIALIZANDO AUTH REPOSITORY ==========');
    print('üèóÔ∏è AuthRepository constru√≠do em: ${DateTime.now().toIso8601String()}');
    print('üèóÔ∏è GoogleSignIn configurado usando Info.plist (SEGURO)');
    print('üèóÔ∏è OAuth configurado para usar browser externo temporariamente');
    
    // Validar configura√ß√£o sem for√ßar nada
    try {
      AuthConfig.validateConfiguration();
      print('‚úÖ Configura√ß√£o validada com sucesso');
    } catch (e) {
      print('‚ö†Ô∏è Aviso de configura√ß√£o: $e');
      // N√ÉO lan√ßar exce√ß√£o aqui para n√£o quebrar o app
    }
    
    print('üèóÔ∏è ===================================================');
    print('');
  }

  @override
  Future<supabase.User?> getCurrentUser() async {
    try {
      return _supabaseClient.auth.currentUser;
    } catch (e, stackTrace) {
      throw DatabaseException(
        message: 'Failed to get current user',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  Future<String> getCurrentUserId() async {
    try {
      final user = await getCurrentUser();
      if (user != null) {
        return user.id;
      } else {
        throw AppAuthException(message: 'No user is authenticated');
      }
    } catch (e, stackTrace) {
      throw DatabaseException(
        message: 'Failed to get current user ID',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  Future<bool> isEmailRegistered(String email) async {
    print('');
    print('üîç ========== VERIFICA√á√ÉO DE EMAIL ==========');
    print('üîç AuthRepository.isEmailRegistered() iniciado');
    print('üîç Email: $email');
    print('üîç Timestamp: ${DateTime.now().toIso8601String()}');
    
    try {
      print('üîç Verificando acesso √† tabela profiles...');
      
      // Primeiro verificar se a tabela 'profiles' existe
      try {
        // Tentativa inicial simples para verificar se a tabela existe
        final tableCheck = await _supabaseClient
            .from('profiles')
            .select('count')
            .limit(1);
        
        print('‚úÖ Tabela profiles existe e est√° acess√≠vel');
        print('üîç Table check result: $tableCheck');
      } catch (tableError) {
        print('‚ö†Ô∏è Erro ao acessar tabela profiles: $tableError');
        
        // Se houver erro ao acessar a tabela, assumir que o email n√£o existe
        // mas logar para investiga√ß√£o
        if (tableError is supabase.PostgrestException) {
          print('‚ö†Ô∏è C√≥digo de erro Postgrest: ${tableError.code}');
          print('‚ö†Ô∏è Mensagem de erro: ${tableError.message}');
          print('‚ö†Ô∏è Details: ${tableError.details}');
          print('‚ö†Ô∏è Hint: ${tableError.hint}');
        }
        
        print('‚ö†Ô∏è Assumindo que email n√£o existe devido a erro de tabela');
        print('üîç ========== FIM VERIFICA√á√ÉO EMAIL (ERROR) ==========');
        // Para efeitos de login existente, vamos assumir que o email n√£o existe
        // se a tabela n√£o estiver acess√≠vel
        return false;
      }
      
      print('üîÑ Executando query para verificar email...');
      // Se a tabela existe, verificar o email
      final result = await _supabaseClient
          .from('profiles')
          .select('email')
          .eq('email', email)
          .limit(1)
          .maybeSingle(); // Usa maybeSingle ao inv√©s de single para evitar exce√ß√µes
      
      print('üîç Query result: $result');
      
      // Se encontrou resultado, o email existe
      final exists = result != null;
      print('üîç Email ${email} ${exists ? "EXISTE" : "N√ÉO EXISTE"} na base de dados');
      print('üîç ========== FIM VERIFICA√á√ÉO EMAIL ==========');
      return exists;
      
    } catch (e) {
      // Logar o erro para diagn√≥stico
      print('‚ö†Ô∏è Erro ao verificar email: $e');
      
      // Se for erro de "n√£o encontrado", retorna false
      if (e is supabase.PostgrestException) {
        print('‚ö†Ô∏è C√≥digo de erro Postgrest: ${e.code}');
        print('‚ö†Ô∏è Mensagem: ${e.message}');
        print('‚ö†Ô∏è Details: ${e.details}');
        print('‚ö†Ô∏è Hint: ${e.hint}');
        
        if (e.code == 'PGRST116') {
          print('üìù Erro de n√£o encontrado, o email n√£o existe');
          print('üîç ========== FIM VERIFICA√á√ÉO EMAIL (NOT FOUND) ==========');
          return false;
        }
      }
      
      // Durante o login com credenciais existentes, vamos assumir que o email existe
      // para permitir a tentativa de login (better safe than sorry)
      // Durante o cadastro, assumir que n√£o existe pode levar a duplica√ß√£o de contas
      print('‚ö†Ô∏è Erro gen√©rico, assumindo que o email existe por precau√ß√£o');
      print('üîç ========== FIM VERIFICA√á√ÉO EMAIL (ERROR - ASSUME EXISTS) ==========');
      return true;
    }
  }

  @override
  Future<supabase.User> signUp(
      String email, String password, String name) async {
    print('');
    print('üìù ========== IN√çCIO SIGNUP ==========');
    print('üìù AuthRepository.signUp() iniciado');
    print('üìù Email: $email');
    print('üìù Nome: $name');
    print('üìù Device: ${_getPlatform()}');
    print('üìù Timestamp: ${DateTime.now().toIso8601String()}');
    
    if (email.isEmpty || password.isEmpty || name.isEmpty) {
      print('‚ùå AuthRepository.signUp(): Valida√ß√£o falhou - campos obrigat√≥rios vazios');
      throw ValidationException(message: 'Email, password and name are required');
    }

    // Valida√ß√£o adicional para iPad
    if (email.length < 3 || !email.contains('@')) {
      print('‚ùå AuthRepository.signUp(): Email inv√°lido');
      throw ValidationException(message: 'Por favor, insira um email v√°lido');
    }

    if (password.length < 6) {
      print('‚ùå AuthRepository.signUp(): Senha muito curta');
      throw ValidationException(message: 'A senha deve ter pelo menos 6 caracteres');
    }

    try {
      print('üîç AuthRepository.signUp(): Verificando se email j√° existe...');
      
      // Verificar primeiro se o email j√° est√° registrado com timeout
      bool emailExists = false;
      try {
        emailExists = await isEmailRegistered(email).timeout(
          const Duration(seconds: 10),
        );
      } catch (timeoutError) {
        print('‚ö†Ô∏è AuthRepository.signUp(): Timeout na verifica√ß√£o de email, continuando...');
        // Se der timeout, assumir que o email n√£o existe e tentar cadastrar
        emailExists = false;
      }
      
      print('üîç AuthRepository.signUp(): Email existe? $emailExists');
      
      if (emailExists) {
        print('‚ùå AuthRepository.signUp(): Email j√° cadastrado: $email');
        throw AppAuthException(
          message: 'Este email j√° est√° cadastrado. Por favor, fa√ßa login.',
          code: 'email_already_exists',
        );
      }

      // URL para redirecionamento ap√≥s verifica√ß√£o de email
      final String redirectUrl = AuthConfig.getConfirmEmailUrl();
      
      // Log detalhado do cadastro
      AuthConfig.logSignUp(email, redirectUrl);
      
      print('üîÑ AuthRepository.signUp(): Chamando Supabase Auth...');
      
      // Prosseguir com o registro se o email n√£o existir
      final response = await _supabaseClient.auth.signUp(
        email: email,
        password: password,
        data: {
          'name': name,
          'full_name': name,
          'device_type': _getPlatform(),
          'signup_timestamp': DateTime.now().toIso8601String(),
        },
        emailRedirectTo: redirectUrl, // URL para redirecionamento ap√≥s verifica√ß√£o
      ).timeout(const Duration(seconds: 30)); // Timeout de 30 segundos

      print('üîç AuthRepository.signUp(): Response do Supabase recebido');
      print('üîç User: ${response.user?.id ?? "null"}');
      print('üîç Session: ${response.session?.accessToken != null ? "presente" : "null"}');

      if (response.user == null) {
        print('‚ùå AuthRepository.signUp(): Nenhum usu√°rio retornado pelo Supabase');
        throw AppAuthException(
          message: 'Falha no cadastro. Tente novamente em alguns instantes.',
          code: 'signup_failed'
        );
      }
      
      // Verificar se o email precisa ser confirmado
      final needsEmailConfirmation = response.session == null;
      print("üîç AuthRepository.signUp(): Email verificado: ${!needsEmailConfirmation}");
      print("üîç AuthRepository.signUp(): Precisa confirma√ß√£o: $needsEmailConfirmation");
      
      if (needsEmailConfirmation) {
        print("üìß AuthRepository.signUp(): Email de confirma√ß√£o enviado para $email");
        // Retornar o usu√°rio, mas sem sess√£o ativa (precisa verificar email)
        // O ViewModel vai tratar essa condi√ß√£o especial
        return response.user!;
      }

      print("‚úÖ AuthRepository.signUp(): Usu√°rio criado e autenticado com sucesso");
      
      // Aguardar um pouco para garantir que o trigger do database execute
      print('‚è≥ Aguardando cria√ß√£o do perfil...');
      await Future.delayed(const Duration(seconds: 2));
      
      // NOVA FUNCIONALIDADE: Verificar se existe n√≠vel pendente para este email
      try {
        print("üîç AuthRepository.signUp(): Verificando n√≠vel de acesso pendente...");
        await _checkPendingUserLevel(response.user!.id, email);
      } catch (e) {
        print("‚ö†Ô∏è AuthRepository.signUp(): Erro ao verificar n√≠vel pendente: $e");
        // N√£o falhar o cadastro por causa disso, apenas logar
      }
      
      print('üìù ========== FIM SIGNUP SUCCESS ==========');
      return response.user!;
      
    } on AppAuthException {
      print('‚ùå AuthRepository.signUp(): Re-lan√ßando AppAuthException');
      // Re-lan√ßar exce√ß√µes AuthException j√° tratadas (como email j√° existente)
      rethrow;
    } on ValidationException {
      print('‚ùå AuthRepository.signUp(): Re-lan√ßando ValidationException');
      // Re-lan√ßar exce√ß√µes de valida√ß√£o
      rethrow;
    } on supabase.AuthException catch (e, stackTrace) {
      print('‚ùå AuthRepository.signUp(): AuthException capturada');
      print('‚ùå Code: ${e.statusCode}');
      print('‚ùå Message: ${e.message}');
      print('‚ùå StackTrace: $stackTrace');
      
      // Melhor tratamento de erros do Supabase
      String message = 'Erro no cadastro. Tente novamente.';
      
      // Mensagens mais amig√°veis para erros comuns
      if (e.message.toLowerCase().contains('already registered') || 
          e.message.toLowerCase().contains('already exists')) {
        message = 'Este email j√° est√° cadastrado. Por favor, fa√ßa login.';
      } else if (e.message.toLowerCase().contains('weak password')) {
        message = 'A senha √© muito fraca. Use pelo menos 6 caracteres com letras e n√∫meros.';
      } else if (e.message.toLowerCase().contains('invalid email')) {
        message = 'O email fornecido √© inv√°lido.';
      } else if (e.message.toLowerCase().contains('rate limit')) {
        message = 'Muitas tentativas de cadastro. Aguarde alguns minutos e tente novamente.';
      } else if (e.message.toLowerCase().contains('network') || 
                 e.message.toLowerCase().contains('connection')) {
        message = 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      } else if (e.message.toLowerCase().contains('timeout')) {
        message = 'Tempo esgotado. Verifique sua conex√£o e tente novamente.';
      }
      
      throw AppAuthException(
        message: message,
        code: e.statusCode?.toString(),
        originalError: e,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      print('‚ùå AuthRepository.signUp(): Exce√ß√£o gen√©rica capturada');
      print('‚ùå Error: $e');
      print('‚ùå StackTrace: $stackTrace');
      print('üìù ========== FIM SIGNUP ERROR ==========');
      
      String message = 'Falha ao registrar usu√°rio. Tente novamente.';
      
      // Verificar se √© erro de rede ou timeout
      if (e.toString().toLowerCase().contains('network') || 
          e.toString().toLowerCase().contains('connection')) {
        message = 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      } else if (e.toString().toLowerCase().contains('timeout')) {
        message = 'Tempo esgotado. Verifique sua conex√£o e tente novamente.';
      }
      
      throw DatabaseException(
        message: message,
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  Future<supabase.User> signIn(String email, String password) async {
    print('');
    print('üîê ========== IN√çCIO LOGIN ==========');
    print('üîê AuthRepository.signIn() iniciado');
    print('üîê Email: $email');
    print('üîê Timestamp: ${DateTime.now().toIso8601String()}');
    
    if (email.isEmpty || password.isEmpty) {
      print('‚ùå AuthRepository.signIn(): Valida√ß√£o falhou - email ou senha vazios');
      throw ValidationException(message: 'Email and password are required');
    }

    try {
      print('üîç AuthRepository.signIn(): Verificando se email existe...');
      // Antes de tentar login, verificar se o email existe
      final emailExists = await isEmailRegistered(email);
      print('üîç AuthRepository.signIn(): Email existe? $emailExists');
      
      if (!emailExists) {
        print('‚ùå AuthRepository.signIn(): Email n√£o encontrado: $email');
        throw AppAuthException(
          message: 'Conta n√£o encontrada. Verifique seu email ou crie uma nova conta.',
          code: 'user_not_found',
        );
      }

      print('üîÑ AuthRepository.signIn(): Tentando login com Supabase...');
      final response = await _supabaseClient.auth.signInWithPassword(
        email: email,
        password: password,
      );

      print('üîç AuthRepository.signIn(): Response do Supabase recebido');
      print('üîç User: ${response.user?.id ?? "null"}');
      print('üîç Session: ${response.session?.accessToken != null ? "presente" : "null"}');
      print('üîç Email confirmed: ${response.user?.emailConfirmedAt != null}');

      if (response.user == null) {
        print('‚ùå AuthRepository.signIn(): Nenhum usu√°rio retornado pelo Supabase');
        throw AppAuthException(message: 'Sign in failed: no user returned');
      }

      print('‚úÖ AuthRepository.signIn(): Login realizado com sucesso');
      print('üîê ========== FIM LOGIN SUCCESS ==========');
      return response.user!;
    } on AppAuthException {
      print('‚ùå AuthRepository.signIn(): Re-lan√ßando AppAuthException');
      // Re-lan√ßar exce√ß√µes AuthException j√° tratadas
      rethrow;
    } on supabase.AuthException catch (e, stackTrace) {
      print('‚ùå AuthRepository.signIn(): AuthException capturada');
      print('‚ùå Code: ${e.statusCode}');
      print('‚ùå Message: ${e.message}');
      print('‚ùå StackTrace: $stackTrace');
      
      String message = e.message;
      
      // Mensagens mais amig√°veis para erros comuns
      if (message.toLowerCase().contains('invalid login')) {
        message = 'Email ou senha incorretos. Por favor, tente novamente.';
      } else if (message.toLowerCase().contains('not confirmed')) {
        message = 'Seu email ainda n√£o foi confirmado. Por favor, verifique sua caixa de entrada.';
      } else if (message.toLowerCase().contains('too many requests')) {
        message = 'Muitas tentativas de login. Por favor, tente novamente mais tarde.';
      } else if (message.toLowerCase().contains('not found') || message.toLowerCase().contains('no user')) {
        message = 'Conta n√£o encontrada. Verifique seu email ou crie uma nova conta.';
      }
      
      throw AppAuthException(
        message: message,
        code: e.statusCode?.toString(),
        originalError: e,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      print('‚ùå AuthRepository.signIn(): Exce√ß√£o gen√©rica capturada');
      print('‚ùå Error: $e');
      print('‚ùå StackTrace: $stackTrace');
      print('üîê ========== FIM LOGIN ERROR ==========');
      
      throw DatabaseException(
        message: 'Falha ao realizar login: ${e.toString()}',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  Future<void> signOut() async {
    try {
      await _supabaseClient.auth.signOut();
    } on supabase.AuthException catch (e, stackTrace) {
      throw AppAuthException(
        message: e.message,
        code: e.statusCode?.toString(),
        originalError: e,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      throw DatabaseException(
        message: 'Failed to sign out user',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  Future<void> resetPassword(String email) async {
    print('');
    print('üîë ========== IN√çCIO RESET SENHA ==========');
    print('üîë AuthRepository.resetPassword() iniciado');
    print('üîë Email: $email');
    print('üîë Timestamp: ${DateTime.now().toIso8601String()}');
    
    if (email.isEmpty) {
      print('‚ùå AuthRepository.resetPassword(): Email vazio');
      throw ValidationException(message: 'Email is required');
    }

    try {
      // URL para redirecionamento ap√≥s redefini√ß√£o de senha - usar sempre a mesma para consist√™ncia
      final String redirectUrl = AuthConfig.getResetPasswordUrl();
      
      // Log detalhado do reset de senha
      AuthConfig.logPasswordReset(email, redirectUrl);
      
      print('üîÑ AuthRepository.resetPassword(): Chamando Supabase resetPasswordForEmail...');
      await _supabaseClient.auth.resetPasswordForEmail(
        email,
        redirectTo: redirectUrl,
      );
      
      print("‚úÖ AuthRepository.resetPassword(): Email de reset enviado com sucesso");
      print('üîë ========== FIM RESET SENHA SUCCESS ==========');
      
    } on supabase.AuthException catch (e, stackTrace) {
      print('‚ùå AuthRepository.resetPassword(): AuthException capturada');
      print('‚ùå Code: ${e.statusCode}');
      print('‚ùå Message: ${e.message}');
      print('‚ùå StackTrace: $stackTrace');
      
      String userMessage = e.message;
      if (e.message.toLowerCase().contains('rate limit')) {
        userMessage = 'Muitas tentativas de reset. Aguarde alguns minutos antes de tentar novamente.';
      } else if (e.message.toLowerCase().contains('not found')) {
        userMessage = 'Email n√£o encontrado. Verifique se voc√™ digitou corretamente.';
      } else if (e.message.toLowerCase().contains('invalid email')) {
        userMessage = 'Email inv√°lido. Por favor, digite um email v√°lido.';
      }
      
      throw AppAuthException(
        message: userMessage,
        code: e.statusCode?.toString(),
        originalError: e,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      print('‚ùå AuthRepository.resetPassword(): Exce√ß√£o gen√©rica capturada');
      print('‚ùå Error: $e');
      print('‚ùå StackTrace: $stackTrace');
      print('üîë ========== FIM RESET SENHA ERROR ==========');
      
      throw DatabaseException(
        message: 'Failed to reset password',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  Future<void> updateProfile({
    String? name, 
    String? photoUrl,
    bool? onboardingSeen,
  }) async {
    final currentUser = _supabaseClient.auth.currentUser;
    if (currentUser == null) {
      throw AppAuthException(message: 'User is not authenticated');
    }

    try {
      // Atualizando atributos do usu√°rio
      if (name != null || photoUrl != null) {
        await _supabaseClient.auth.updateUser(
          supabase.UserAttributes(
            data: {
              if (name != null) 'name': name,
              if (photoUrl != null) 'avatar_url': photoUrl,
            },
          ),
        );
      }
      
      // Atualizando campos extras na tabela de perfis
      if (onboardingSeen != null) {
        await _supabaseClient
          .from('profiles')
          .update({'onboarding_seen': onboardingSeen})
          .eq('id', currentUser.id);
      }
    } on supabase.AuthException catch (e, stackTrace) {
      throw AppAuthException(
        message: e.message,
        code: e.statusCode?.toString(),
        originalError: e,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      throw DatabaseException(
        message: 'Failed to update profile',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }
  
  @override
  Future<supabase.Session?> signInWithGoogle() async {
    print('');
    print('üîê ========== IN√çCIO GOOGLE OAUTH ==========');
    print('üîê AuthRepository.signInWithGoogle() iniciado');
    print('üîê Timestamp: ${DateTime.now().toIso8601String()}');
    
    try {
      // VERIFICA√á√ÉO DE SEGURAN√áA: Testar se GoogleSignIn est√° configurado
      try {
        print('üîç Verificando configura√ß√£o do GoogleSignIn...');
        // Apenas verificar se o GoogleSignIn est√° acess√≠vel
        final isConfigured = _googleSignIn != null;
        print('‚úÖ GoogleSignIn est√° ${isConfigured ? "configurado" : "N√ÉO configurado"}');
        
        if (!isConfigured) {
          print('‚ùå GoogleSignIn n√£o est√° configurado corretamente');
          throw AppAuthException(
            message: 'Google Sign In n√£o est√° configurado. Verifique o Info.plist.',
            code: 'google_signin_not_configured'
          );
        }
      } catch (e) {
        print('‚ö†Ô∏è Erro ao verificar GoogleSignIn: $e');
        // Se houver qualquer erro, usar apenas OAuth web
        print('üîÑ Fallback para OAuth web apenas');
      }
      
      final platform = _getPlatform();
      print('üîê Platform detectada: $platform');
      
      // IMPORTANTE: Usar deep link nativo para iOS/Android
      final String redirectUrl = (platform == 'ios' || platform == 'android')
          ? 'rayclub://login-callback/'
          : 'https://zsbbgchsjiuicwvtrldn.supabase.co/auth/v1/callback';
      
      print('');
      print('üîç ========== CONFIGURA√á√ÉO DE REDIRECIONAMENTO ==========');
      print('üîç Platform: $platform');
      print('üîç Redirect URL escolhida: $redirectUrl');
      print('üîç Tipo de redirect: ${redirectUrl.startsWith('rayclub://') ? "Deep Link Nativo" : "URL HTTPS"}');
      print('üîç ===================================================');
      print('');
      
      // Log detalhado da tentativa OAuth
      AuthConfig.logOAuthAttempt('Google', platform, redirectUrl);
      
      print('üîÑ ========== INICIANDO OAUTH ==========');
      
      try {
        // Para mobile, vamos usar uma estrat√©gia mais robusta
        if (platform == 'ios' || platform == 'android') {
          print('üì± Tentando OAuth com configura√ß√µes mobile...');
          
          // DIAGN√ìSTICO: Imprimir estado atual do Supabase
          print('');
          print('üîç ========== ESTADO SUPABASE ==========');
          print('üîç Sess√£o atual: ${_supabaseClient.auth.currentSession != null ? "presente" : "null"}');
          print('üîç Usu√°rio atual: ${_supabaseClient.auth.currentUser?.email ?? "n√£o autenticado"}');
          print('üîç ====================================');
          print('');
          
          // Tentar sem especificar authScreenLaunchMode (como na vers√£o antiga)
          print('üîÑ Tentando OAuth sem especificar authScreenLaunchMode...');
          
          final response = await _supabaseClient.auth.signInWithOAuth(
            supabase.OAuthProvider.google,
            redirectTo: redirectUrl,
            // N√£o especificar authScreenLaunchMode - deixar o Supabase decidir
          );
          
          print('üîç AuthRepository.signInWithGoogle(): OAuth response: $response');
          
          if (!response) {
            throw AppAuthException(message: 'OAuth falhou - usu√°rio pode ter cancelado');
          }
          
          // Aguardar sess√£o com timeout (como na vers√£o antiga)
          print('üì± AuthRepository.signInWithGoogle(): Aguardando sess√£o para mobile...');
          
          int attempts = 0;
          const maxAttempts = 30; // 30 segundos como na vers√£o antiga
          
          while (attempts < maxAttempts) {
            await Future.delayed(const Duration(seconds: 1));
            
            final session = getCurrentSession();
            if (session != null) {
              print('‚úÖ AuthRepository.signInWithGoogle(): Sess√£o obtida ap√≥s ${attempts} segundos');
              print('üîê ========== FIM GOOGLE OAUTH SUCCESS ==========');
              return session;
            }
            
            attempts++;
            print('‚è≥ OAuth - Aguardando sess√£o... Tentativa $attempts/$maxAttempts');
          }
          
          print('‚ö†Ô∏è AuthRepository.signInWithGoogle(): Timeout aguardando sess√£o OAuth');
          throw AppAuthException(message: 'Tempo esgotado aguardando pela sess√£o do Google');
          
        } else {
          // Para web, usar configura√ß√£o padr√£o
          print('üåê AuthRepository.signInWithGoogle(): OAuth web iniciado');
          
          final response = await _supabaseClient.auth.signInWithOAuth(
            supabase.OAuthProvider.google,
            redirectTo: 'https://rayclub.vercel.app/auth/callback',
          );
          
          if (!response) {
            throw AppAuthException(message: 'OAuth falhou');
          }
          
          return getCurrentSession();
        }
        
      } catch (webError) {
        print('‚ùå AuthRepository.signInWithGoogle(): Erro no OAuth: $webError');
        
        // DIAGN√ìSTICO: Analisar o erro em detalhes
        print('');
        print('üîç ========== AN√ÅLISE DO ERRO ==========');
        print('üîç Tipo do erro: ${webError.runtimeType}');
        print('üîç Mensagem: $webError');
        if (webError is supabase.AuthException) {
          print('üîç AuthException Code: ${webError.statusCode}');
          print('üîç AuthException Message: ${webError.message}');
        }
        print('üîç =====================================');
        print('');
        
        throw AppAuthException(message: 'Falha no OAuth: $webError');
      }
      
    } catch (e) {
      print('‚ùå AuthRepository.signInWithGoogle(): Erro geral: $e');
      print('‚ùå StackTrace: ${StackTrace.current}');
      print('üîê =====================================');
      print('');
      
      throw AppAuthException(message: 'Falha no login com Google: ${e.toString()}');
    }
  }
  
  @override
  Future<supabase.Session?> signInWithApple() async {
    print('');
    print('üçé ========== IN√çCIO APPLE SIGN IN NATIVO ==========');
    print('üçé AuthRepository.signInWithApple() iniciado');
    print('üçé Timestamp: ${DateTime.now().toIso8601String()}');
    
    try {
      final platform = _getPlatform();
      print('üçé Platform detectada: $platform');
      
      // Verificar se est√° no iOS/iPadOS
      if (platform != 'ios') {
        throw AppAuthException(
          message: 'Sign in with Apple s√≥ est√° dispon√≠vel no iOS/iPadOS',
          code: 'platform_not_supported'
        );
      }
      
      print('üçé Iniciando Sign In with Apple 100% nativo...');
      
      // 1. Verificar se o Sign in with Apple est√° dispon√≠vel
      final isAvailable = await SignInWithApple.isAvailable();
      if (!isAvailable) {
        throw AppAuthException(
          message: 'Sign in with Apple n√£o est√° dispon√≠vel neste dispositivo',
          code: 'apple_signin_not_available'
        );
      }
      
      print('‚úÖ Sign in with Apple est√° dispon√≠vel');
      
      // 2. Obter credenciais do Apple usando o pacote nativo SEM nonce
      // O nonce ser√° gerado automaticamente pelo Supabase
      print('üîÑ Solicitando credenciais Apple...');
      final credential = await SignInWithApple.getAppleIDCredential(
        scopes: [
          AppleIDAuthorizationScopes.email,
          AppleIDAuthorizationScopes.fullName,
        ],
        // N√ÉO especificar nonce - deixar o Supabase gerenciar
      );
      
      print('‚úÖ Credenciais Apple obtidas com sucesso');
      print('üîç User ID: ${credential.userIdentifier}');
      print('üîç Email: ${credential.email ?? "n√£o fornecido"}');
      print('üîç Nome: ${credential.givenName ?? ""} ${credential.familyName ?? ""}');
      print('üîç Identity Token presente: ${credential.identityToken != null}');
      print('üîç Authorization Code presente: ${credential.authorizationCode != null}');
      
      // 3. Verificar se temos os tokens necess√°rios
      if (credential.identityToken == null) {
        throw AppAuthException(
          message: 'Token de identidade do Apple n√£o foi fornecido',
          code: 'missing_identity_token'
        );
      }
      
      print('‚úÖ Identity token obtido');
      
      print('üîÑ Autenticando no Supabase com credenciais Apple...');
      
      // 4. Autenticar no Supabase usando as credenciais nativas SEM nonce customizado
      final response = await _supabaseClient.auth.signInWithIdToken(
        provider: supabase.OAuthProvider.apple,
        idToken: credential.identityToken!,
        // N√ÉO especificar nonce - deixar o Supabase validar automaticamente
      );
      
      print('üîç Response do Supabase:');
      print('  - Session presente: ${response.session != null}');
      print('  - User presente: ${response.user != null}');
      
      if (response.session == null) {
        throw AppAuthException(
          message: 'Falha na autentica√ß√£o: sess√£o n√£o criada pelo Supabase',
          code: 'session_creation_failed'
        );
      }
      
      if (response.user == null) {
        throw AppAuthException(
          message: 'Falha na autentica√ß√£o: usu√°rio n√£o criado pelo Supabase', 
          code: 'user_creation_failed'
        );
      }
      
      // 5. Aguardar um pouco para garantir que o trigger do database execute
      print('‚è≥ Aguardando cria√ß√£o do perfil...');
      await Future.delayed(const Duration(seconds: 2));
      
      // 6. Verificar se o perfil foi criado corretamente
      try {
        await _ensureUserProfile(response.user!);
        print('‚úÖ Perfil verificado/criado com sucesso');
      } catch (e) {
        print('‚ö†Ô∏è Erro ao criar/verificar perfil: $e');
        // N√£o falhar o login por causa do perfil, mas logar o erro
      }
      
      print('‚úÖ Autentica√ß√£o Apple conclu√≠da com sucesso!');
      print('üîç User ID: ${response.user!.id}');
      print('üîç Email: ${response.user!.email ?? "n√£o fornecido"}');
      print('üîç Provider: ${response.user!.appMetadata['provider'] ?? "n√£o informado"}');
      print('üçé ========== FIM APPLE SIGN IN SUCCESS ==========');
      
      return response.session;
      
    } on SignInWithAppleAuthorizationException catch (e) {
      print('‚ùå SignInWithAppleAuthorizationException: $e');
      print('üçé ========== FIM APPLE SIGN IN ERROR ==========');
      
      // Identificar o tipo de erro espec√≠fico
      String userMessage;
      switch (e.code) {
        case AuthorizationErrorCode.canceled:
          userMessage = 'Login cancelado pelo usu√°rio';
          break;
        case AuthorizationErrorCode.failed:
          userMessage = 'Falha na autentica√ß√£o com Apple. Verifique sua conex√£o e tente novamente.';
          break;
        case AuthorizationErrorCode.invalidResponse:
          userMessage = 'Resposta inv√°lida do Apple. Tente novamente em alguns instantes.';
          break;
        case AuthorizationErrorCode.notHandled:
          userMessage = 'Login com Apple n√£o est√° dispon√≠vel neste dispositivo.';
          break;
        case AuthorizationErrorCode.unknown:
        default:
          // Para erro 1000, tentar novamente pode resolver
          userMessage = 'Erro tempor√°rio no Apple Sign In. Tente novamente em alguns instantes.';
          break;
      }
      
      throw AppAuthException(
        message: userMessage,
        code: e.code.toString(),
        originalError: e,
      );
      
    } on supabase.AuthException catch (e) {
      print('‚ùå AuthException durante Apple Sign In:');
      print('‚ùå Code: ${e.statusCode}');
      print('‚ùå Message: ${e.message}');
      print('üçé ========== FIM APPLE SIGN IN ERROR ==========');
      
      String userMessage = 'Erro na autentica√ß√£o. Tente novamente.';
      
      // Mensagens mais espec√≠ficas baseadas no erro
      if (e.message.toLowerCase().contains('invalid_client')) {
        userMessage = 'Configura√ß√£o do Apple Sign In inv√°lida. Entre em contato com o suporte.';
      } else if (e.message.toLowerCase().contains('invalid_grant')) {
        userMessage = 'Token do Apple expirou. Tente fazer login novamente.';
      } else if (e.message.toLowerCase().contains('unauthorized')) {
        userMessage = 'Acesso n√£o autorizado. Verifique suas configura√ß√µes de Apple ID.';
      } else if (e.message.toLowerCase().contains('database error')) {
        userMessage = 'Erro interno do servidor. Tente novamente em alguns instantes.';
      } else if (e.message.toLowerCase().contains('network')) {
        userMessage = 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      } else if (e.message.toLowerCase().contains('nonces mismatch')) {
        userMessage = 'Erro de sincroniza√ß√£o. Tente fazer login novamente.';
      }
      
      throw AppAuthException(
        message: userMessage,
        code: e.statusCode?.toString(),
        originalError: e,
      );
      
    } catch (e, stackTrace) {
      print('‚ùå Erro geral durante Apple Sign In: $e');
      print('üçé StackTrace: $stackTrace');
      print('üçé ========== FIM APPLE SIGN IN ERROR ==========');
      
      String userMessage = 'Erro inesperado no login com Apple. Tente novamente ou use email/senha.';
      
      // Verificar se √© erro de rede
      if (e.toString().toLowerCase().contains('network') || 
          e.toString().toLowerCase().contains('connection')) {
        userMessage = 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      }
      
      throw AppAuthException(
        message: userMessage,
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  /// Garante que o perfil do usu√°rio existe ap√≥s autentica√ß√£o
  Future<void> _ensureUserProfile(supabase.User user) async {
    try {
      // Verificar se o perfil j√° existe
      final existingProfile = await _supabaseClient
          .from('profiles')
          .select()
          .eq('id', user.id)
          .maybeSingle();
      
      if (existingProfile == null) {
        // Criar perfil se n√£o existir COM account_type = 'basic'
        await _supabaseClient.from('profiles').insert({
          'id': user.id,
          'email': user.email,
          'name': user.userMetadata?['full_name'] ?? 
                  user.userMetadata?['name'] ?? 
                  user.email?.split('@').first ?? 
                  'Usu√°rio',
          'account_type': 'basic',  // ‚úÖ CAMPO ADICIONADO PARA GARANTIR BASIC
          'created_at': DateTime.now().toIso8601String(),
          'updated_at': DateTime.now().toIso8601String(),
        });
        
        print('‚úÖ Perfil criado para usu√°rio ${user.id}');
      } else {
        print('‚úÖ Perfil j√° existe para usu√°rio ${user.id}');
      }
    } catch (e) {
      print('‚ùå Erro ao criar/verificar perfil: $e');
      rethrow;
    }
  }

  String _getPlatform() {
    if (identical(0, 0.0)) {
      return 'web';
    }
    
    if (Platform.isIOS) return 'ios';
    if (Platform.isAndroid) return 'android';
    if (Platform.isMacOS) return 'macos';
    if (Platform.isWindows) return 'windows';
    if (Platform.isLinux) return 'linux';
    
    return 'unknown';
  }

  /// Obt√©m a sess√£o atual se existir
  supabase.Session? getCurrentSession() {
    final session = _supabaseClient.auth.currentSession;
    print('');
    print('üìã ========== STATUS SESS√ÉO ATUAL ==========');
    print('üìã AuthRepository.getCurrentSession() chamado');
    print('üìã Timestamp: ${DateTime.now().toIso8601String()}');
    
    if (session != null) {
      print('‚úÖ Sess√£o ATIVA encontrada');
      print('üìã User ID: ${session.user.id}');
      print('üìã Email: ${session.user.email ?? "n√£o informado"}');
      print('üìã Access Token presente: ${session.accessToken.isNotEmpty}');
      print('üìã Refresh Token presente: ${session.refreshToken?.isNotEmpty ?? false}');
      print('üìã Expires At: ${session.expiresAt != null ? DateTime.fromMillisecondsSinceEpoch(session.expiresAt! * 1000) : "n√£o definido"}');
      print('üìã Provider: ${session.user.appMetadata['provider'] ?? "n√£o informado"}');
    } else {
      print('‚ùå NENHUMA sess√£o ativa encontrada');
    }
    
    print('üìã ==========================================');
    print('');
    return session;
  }
  
  /// Obt√©m o perfil do usu√°rio atual
  @override
  Future<supabase.User?> getUserProfile() async {
    print('');
    print('üë§ ========== GET USER PROFILE ==========');
    print('üë§ AuthRepository.getUserProfile() iniciado');
    print('üë§ Timestamp: ${DateTime.now().toIso8601String()}');
    
    try {
      // Apenas retorna o usu√°rio atual do Supabase
      final user = _supabaseClient.auth.currentUser;
      
      if (user != null) {
        print('‚úÖ Usu√°rio atual encontrado');
        print('üë§ User ID: ${user.id}');
        print('üë§ Email: ${user.email ?? "n√£o informado"}');
        print('üë§ Email confirmado: ${user.emailConfirmedAt != null}');
        print('üë§ Criado em: ${user.createdAt}');
        print('üë§ √öltima atualiza√ß√£o: ${user.updatedAt}');
        print('üë§ Provider: ${user.appMetadata['provider'] ?? "email"}');
        print('üë§ Role: ${user.role ?? "n√£o definido"}');
      } else {
        print('‚ùå Nenhum usu√°rio atual encontrado');
      }
      
      print('üë§ =======================================');
      print('');
      return user;
    } catch (e, stackTrace) {
      print('‚ùå Erro ao obter perfil do usu√°rio: $e');
      print('‚ùå StackTrace: $stackTrace');
      print('üë§ =======================================');
      print('');
      
      throw AppAuthException(
        message: 'Falha ao obter perfil do usu√°rio',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  /// Renova a sess√£o do usu√°rio atual
  @override
  Future<void> refreshSession() async {
    try {
      await _supabaseClient.auth.refreshSession();
    } catch (e, stackTrace) {
      throw AppAuthException(
        message: 'Erro ao renovar sess√£o',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }
  
  /// Reenvia o email de verifica√ß√£o
  @override
  Future<void> resendVerificationEmail(String email, String redirectUrl) async {
    if (email.isEmpty) {
      throw ValidationException(message: 'Email is required');
    }

    try {
      debugPrint("üîç AuthRepository: Reenviando email de verifica√ß√£o para: $email");
      
      // Se o redirectUrl fornecido estiver vazio, usar o padr√£o
      String finalRedirectUrl = redirectUrl.isNotEmpty 
          ? redirectUrl 
          : (_getPlatform() == 'web' ? 'https://rayclub.com.br/confirm/' : 'rayclub://login');
      
      debugPrint("üîç AuthRepository: Usando URL de redirecionamento: $finalRedirectUrl");
      
      // Usar o m√©todo Supabase para reenviar o email de verifica√ß√£o
      await _supabaseClient.auth.resend(
        type: supabase.OtpType.signup,
        email: email,
        emailRedirectTo: finalRedirectUrl,
      );
      
      debugPrint("‚úÖ AuthRepository: Email de verifica√ß√£o reenviado com sucesso");
    } on supabase.AuthException catch (e, stackTrace) {
      debugPrint("‚ùå AuthRepository: Erro AuthException ao reenviar email: ${e.message}");
      throw AppAuthException(
        message: e.message,
        code: e.statusCode?.toString(),
        originalError: e,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      debugPrint("‚ùå AuthRepository: Erro gen√©rico ao reenviar email: $e");
      throw DatabaseException(
        message: 'Falha ao reenviar email de verifica√ß√£o: ${e.toString()}',
        originalError: e,
        stackTrace: stackTrace,
      );
    }
  }

  /// M√©todo privado para verificar e aplicar n√≠vel pendente
  Future<void> _checkPendingUserLevel(String userId, String email) async {
    try {
      print("üîç Verificando n√≠vel pendente para usu√°rio: $userId, email: $email");
      
      final response = await _supabaseClient.rpc('apply_pending_user_level', 
        params: {
          'user_id_param': userId,
          'email_param': email,
        }
      );
      
      if (response != null) {
        print("‚úÖ Resposta da verifica√ß√£o de n√≠vel pendente: $response");
        
        // Log do resultado
        final success = response['success'] ?? false;
        final levelApplied = response['level_applied'] ?? 'basic';
        final message = response['message'] ?? 'Sem mensagem';
        
        print("üìä N√≠vel aplicado: $levelApplied");
        print("üìù Resultado: $message");
        
        if (success && levelApplied != 'basic') {
          print("üéâ N√≠vel premium aplicado com sucesso ao usu√°rio!");
        }
      }
    } catch (e) {
      print("‚ùå Erro ao verificar n√≠vel pendente: $e");
      // N√£o propagar o erro para n√£o afetar o cadastro
    }
  }
} 
